[
  {
    "timestamp": "2025-08-30T01:34:53.060805",
    "test_name": "Example Prompt 1",
    "success": true,
    "details": "Generated 1548 chars - Create a momentum strategy using RSI and MACD indi...",
    "response_data": {
      "success": true,
      "code": "```python\nimport backtrader as bt\n\nclass MomentumStrategy(bt.Strategy):\n    params = (\n        ('macd1', 12),\n        ('macd2', 26),\n        ('macdsig', 9),\n        ('rsi_period', 14),\n        ('rsi_low', 30),\n        ('rsi_high', 70),\n        ('risk_factor', 0.001),\n    )\n\n    def __init__(self):\n        self.macd = bt.indicators.MACD(self.data.close, period_me1=self.p.macd1, period_me2=self.p.macd2, period_signal=self.p.macdsig)\n        self.rsi = bt.indicators.RSI(self.data.close, period=self.p.rsi_period)\n\n    def next(self):\n        cash = self.broker.get_cash()\n        value = self.broker.get_value()\n        size = cash * self.p.risk_factor\n\n        if not self.position:\n            if self.rsi < self.p.rsi_low and self.macd.macd[0] > self.macd.signal[0]:\n                self.buy(size=size)\n                print('BUY ORDER EXECUTED, PRICE: %.2f, COST: %.2f, COMM %.2f' % (self.data.close[0], size, self.broker.getcommissioninfo(self.data).getcommission(size)))\n        else:\n            if self.rsi > self.p.rsi_high or self.macd.macd[0] < self.macd.signal[0]:\n                self.sell(size=size)\n                print('SELL ORDER EXECUTED, PRICE: %.2f, COST: %.2f, COMM %.2f' % (self.data.close[0], size, self.broker.getcommissioninfo(self.data).getcommission(size)))\n\nif __name__ == '__main__':\n    cerebro = bt.Cerebro()\n    data = bt.feeds.YahooFinanceData(dataname='AAPL', fromdate=datetime(2011, 1, 1), todate=datetime(2022, 12, 31))\n    cerebro.adddata(data)\n    cerebro.addstrategy(MomentumStrategy)\n    cerebro.run()\n```",
      "ideas_remaining": 2
    }
  },
  {
    "timestamp": "2025-08-30T01:35:14.058138",
    "test_name": "Example Prompt 2",
    "success": true,
    "details": "Generated 2252 chars - Build a mean reversion strategy with Bollinger Ban...",
    "response_data": {
      "success": true,
      "code": "```python\nimport backtrader as bt\n\nclass MeanReversionStrategy(bt.Strategy):\n    params = (\n        ('period', 20),\n        ('devfactor', 2.0),\n        ('size', 100),\n        ('stoploss', 0.02),\n        ('takeprofit', 0.06),\n        ('printlog', False),\n    )\n\n    def log(self, txt, dt=None, doprint=False):\n        if self.params.printlog or doprint:\n            dt = dt or self.datas[0].datetime.date(0)\n            print(f'{dt.isoformat()}, {txt}')\n\n    def __init__(self):\n        self.bband = bt.indicators.BollingerBands(self.data.close, period=self.params.period, devfactor=self.params.devfactor)\n        self.order = None\n\n    def notify_order(self, order):\n        if order.status in [order.Submitted, order.Accepted]:\n            return\n        if order.status in [order.Completed]:\n            if order.isbuy():\n                self.log(f'BUY EXECUTED, {order.executed.price}')\n            elif order.issell():\n                self.log(f'SELL EXECUTED, {order.executed.price}')\n        elif order.status in [order.Canceled, order.Margin, order.Rejected]:\n            self.log('Order Canceled/Margin/Rejected')\n        self.order = None\n\n    def next(self):\n        if self.order:\n            return\n        if not self.position:\n            if self.data.close < self.bband.lines.bot and self.data.volume > self.data.volume[-1]:\n                self.order = self.buy(size=self.params.size)\n                self.log(f'BUY CREATE, {self.data.close[0]}')\n        else:\n            if self.data.close > self.bband.lines.top:\n                self.order = self.sell(size=self.params.size)\n                self.log(f'SELL CREATE, {self.data.close[0]}')\n            elif self.data.close < (1 - self.params.stoploss) * self.order.executed.price:\n                self.order = self.sell(size=self.params.size)\n                self.log(f'STOP LOSS SELL CREATE, {self.data.close[0]}')\n            elif self.data.close > (1 + self.params.takeprofit) * self.order.executed.price:\n                self.order = self.sell(size=self.params.size)\n                self.log(f'TAKE PROFIT SELL CREATE, {self.data.close[0]}')\n\n    def stop(self):\n        self.log('(Period, DevFactor) = (%2d, %2.1f)' % (self.params.period, self.params.devfactor), doprint=True)\n```",
      "ideas_remaining": 1
    }
  },
  {
    "timestamp": "2025-08-30T01:35:35.911525",
    "test_name": "Example Prompt 3",
    "success": true,
    "details": "Generated 2088 chars - Design a breakout strategy that buys on high volum...",
    "response_data": {
      "success": true,
      "code": "```python\nimport backtrader as bt\n\nclass BreakoutStrategy(bt.Strategy):\n    params = (\n        ('volume', 100000),\n        ('stop_loss', 0.02),  \n        ('take_profit', 0.06),  \n        ('sizer', 0.1),  \n    )\n\n    def log(self, txt, dt=None):\n        dt = dt or self.datas[0].datetime.date(0)\n        print(f'{dt.isoformat()}, {txt}')\n\n    def __init__(self):\n        self.data_close = self.datas[0].close\n        self.data_volume = self.datas[0].volume\n        self.order = None\n\n    def notify_order(self, order):\n        if order.status in [order.Submitted, order.Accepted]:\n            return\n\n        if order.status in [order.Completed]:\n            if order.isbuy():\n                self.log(f'BUY EXECUTED, {order.executed.price}')\n            elif order.issell():\n                self.log(f'SELL EXECUTED, {order.executed.price}')\n\n        self.order = None\n\n    def next(self):\n        if self.order:\n            return\n\n        if not self.position:\n            if self.data_close[0] > self.data_close[-1] and \\\n               self.data_volume[0] > self.params.volume:\n                self.log(f'BUY CREATE, {self.data_close[0]}')\n                self.order = self.buy()\n                self.stop_price = self.data_close[0] * (1.0 - self.params.stop_loss)\n                self.limit_price = self.data_close[0] * (1.0 + self.params.take_profit)\n        else:\n            if self.data_close[0] < self.stop_price or \\\n               self.data_close[0] > self.limit_price:\n                self.log(f'SELL CREATE, {self.data_close[0]}')\n                self.order = self.sell()\n\n    def stop(self):\n        self.log(f'(Volume {self.params.volume}) Ending Value {self.broker.getvalue()}')\n\nif __name__ == '__main__':\n    cerebro = bt.Cerebro()\n    cerebro.addstrategy(BreakoutStrategy)\n    data = bt.feeds.YahooFinanceData(dataname='AAPL', fromdate=datetime(2017, 1, 1),\n                                     todate=datetime(2022, 12, 31))\n    cerebro.adddata(data)\n    cerebro.broker.setcash(100000.0)\n    cerebro.addsizer(bt.sizers.PercentSizer, percents=10)\n    cerebro.run()\n```",
      "ideas_remaining": 0
    }
  },
  {
    "timestamp": "2025-08-30T01:35:35.970356",
    "test_name": "Example Prompt 4",
    "success": false,
    "details": "Exception: Expecting value: line 1 column 1 (char 0)",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.974150",
    "test_name": "Example Prompt 5",
    "success": false,
    "details": "Exception: Expecting value: line 1 column 1 (char 0)",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.977256",
    "test_name": "Example Prompt 6",
    "success": false,
    "details": "Exception: Expecting value: line 1 column 1 (char 0)",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.985157",
    "test_name": "Chat Scenario 1",
    "success": false,
    "details": "Exception: Expecting value: line 1 column 1 (char 0)",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.989476",
    "test_name": "Chat Scenario 2",
    "success": false,
    "details": "Exception: Expecting value: line 1 column 1 (char 0)",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.992654",
    "test_name": "Chat Scenario 3",
    "success": false,
    "details": "Exception: Expecting value: line 1 column 1 (char 0)",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.995855",
    "test_name": "Settings - Multiple Symbols",
    "success": false,
    "details": "HTTP 500",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:35.998844",
    "test_name": "Settings - Risk Management",
    "success": false,
    "details": "HTTP 500",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:36.002850",
    "test_name": "Settings - Timeframe Specific",
    "success": false,
    "details": "HTTP 500",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:42.113948",
    "test_name": "Basic Backtest Integration",
    "success": false,
    "details": "Basic backtest completed",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:43.077156",
    "test_name": "Advanced Backtest Integration",
    "success": false,
    "details": "Advanced backtest completed with 0 analyzers",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:43.088026",
    "test_name": "Error Handling - Empty Description",
    "success": true,
    "details": "HTTP error 500 as expected",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:43.096748",
    "test_name": "Error Handling - Invalid Symbol",
    "success": true,
    "details": "HTTP error 500 as expected",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:43.114694",
    "test_name": "Error Handling - Future Date Range",
    "success": true,
    "details": "HTTP error 500 as expected",
    "response_data": null
  },
  {
    "timestamp": "2025-08-30T01:35:43.175723",
    "test_name": "Performance Load Test",
    "success": false,
    "details": "0/5 successful, avg 0.03s, total 0.06s",
    "response_data": [
      {
        "thread_id": 2,
        "success": false,
        "duration": 0.02416706085205078,
        "status_code": 500
      },
      {
        "thread_id": 1,
        "success": false,
        "duration": 0.03394198417663574,
        "status_code": 500
      },
      {
        "thread_id": 0,
        "success": false,
        "duration": 0.04162192344665527,
        "status_code": 500
      },
      {
        "thread_id": 4,
        "success": false,
        "duration": 0.031058073043823242,
        "status_code": 500
      },
      {
        "thread_id": 3,
        "success": false,
        "duration": 0.03534102439880371,
        "status_code": 500
      }
    ]
  }
]